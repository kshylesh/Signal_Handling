#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <signal.h>
#include <pthread.h>
#include <semaphore.h>
#include <time.h>
/*Sleep time before generating a signal*/
#define SLEEP_TIME 1

/*Atomic vaariable that is shared between signal handler and main thread,
Used to terminate operation*/

volatile sig_atomic_t ter_thread = 0;



/*Semaphore to wait upon*/
static sem_t task_sem;

/*Signal generating thread*/
void* sig_thread(void* dummy)
{
	sleep(SLEEP_TIME);

	/*Signal being sent after a short delay */
	kill(0,SIGUSR1);
    return NULL;
}

/*Signal handler which directs to terminate operation,
as soon as process receives signal*/
void sig_handler(int sig_num)
{
	/*termination flag being set*/
	ter_thread = 1;
	return;
}
/*Main thread that carrier out various tasks */
int main(void)
{   
    int ret;
    struct sigaction sig_action;
    int loop_break=0;
	pthread_t sig_thread_id;
	sigset_t block_mask;
	struct sched_param params, new_params;
    int policy;
    /*Getting thread id of main thread*/
    pthread_t main_thread = pthread_self();
    struct timespec sleep_until,rem_time;
    sleep_until.tv_sec=10;
    sleep_until.tv_nsec=0;
    /*Initialization of semphore to value 0*/
    sem_init(&task_sem,0,0);
	memset(&sig_action, 0, sizeof(sig_action));
	sigfillset(&block_mask);
	sig_action.sa_mask = block_mask;
	/*Assigning signal handler for signal SIGUSR1*/
	sig_action.sa_handler = &sig_handler;
    sigaction(SIGUSR1, &sig_action, NULL);
    
    
	printf("Checking signal handling functionality when the thread is running\n");
    
	/*Create a thread that generates signal after a delay */
	pthread_create(&sig_thread_id,NULL,&sig_thread,NULL);
	/*go in a busy loop until ter flag is set by signal handler 
	upon receiving signal from signal generating thread that was
	created*/
	do
	{	
		if (ter_thread!=0)
		{
			loop_break = 1;
			printf("Signal Handler requested to stop \n");
			ter_thread = 0;
		}
	}while(loop_break==0);
	loop_break = 0;
	/*Wait for the signal generating thread to join*/
    pthread_join(sig_thread_id, NULL); 
    
   
	printf(" Checking signal handling functionality when the thread is runnable(Realtime priority)\n");
    
    /*Get the main thread priority,policy into a structure "params"*/
    ret = pthread_getschedparam(main_thread, &policy, &params);
    if(ret != 0)
    {
        printf("Error retrieving scheduling paramers\n");
        return -1;
    }
    else
    {
		printf("Present priority of the task is %d\n",params.sched_priority);
	}
	
	/*Getting the highest priority from round robin schedule class*/
	new_params.sched_priority = sched_get_priority_max(SCHED_RR);
	printf("Trying to set thread realtime priority = %d\n",new_params.sched_priority);
	 
	/*set the main thread priority to new policy and highest priority that was 
	retreived before*/
	ret = pthread_setschedparam(main_thread, SCHED_RR, &new_params);
	if (ret != 0)
	{
		perror("Error : setting thread realtime priority:");
		return -1;
	}
	else
	{
		printf("Successful in setting thread realtime priority\n");
	}
	/*Create a thread that generates signal after a delay */
	pthread_create(&sig_thread_id,NULL,&sig_thread,NULL);
	/*go in a busy loop until ter flag is set by signal handler 
	upon receiving signal from signal generating thread that was
	created*/
	do
	{
		if (ter_thread!=0)
		{
			loop_break = 1;
			printf("Signal Handler requested to stop\n ");
			ter_thread = 0;
		}
	}while(loop_break==0);
	loop_break = 0;
    /*Wait for the signal generating thread to join*/
    pthread_join(sig_thread_id, NULL);
   
   /*set the priority of main thread to previous priority
   and previous policy*/
	ret = pthread_setschedparam(main_thread, SCHED_OTHER, &params);
	if (ret != 0)
	{
		printf("Error in setting thread back to normal priority\n");
		return -1;
	}
	else
	{
		printf("Successful in setting thread to normal priority\n");
	}

    printf("Checking signal handling functionality when the thread is blocked by a semaphore\n");
    /*Create a thread that generates signal after a delay */
    pthread_create(&sig_thread_id,NULL,&sig_thread,NULL);
	
	printf("waiting for the semaphore\n");
	/*wait on a semaphore contionously,without timeout
	but into an TASK_INTERRUPTIBLE STATE, it gets blocked 
	because there is no post from anywhere else and hence until 
	it is interrupted it will be in blocked state*/
    ret = sem_wait(&task_sem);
    /*Breaks out returning -EINTR, indicating interruption
    by a signal,which is generated by signal generation thread
    after a delay*/
    /*NOTE : if there was a post from somewhere else, before the signal 
    could arrive after the specified delay, then the semaphore would be successful
    in acquiring and hence it wouldnt return any error*/
    /*This can be made possible by placing a post just before the kill in signal
    generation thread*/
    if(ret < 0)
    {
		perror("Error acquiring semaphore:");
	}
	else
	{
		printf("Semaphore released without any error\n");
		return 0;
	}
	
     /*Wait for the signal generating thread to join*/
    pthread_join(sig_thread_id, NULL); 
    ter_thread = 0;
    printf(" Checking signal handling functionality when the thread is delayed\n");
   	/*Create a thread that generates signal after a delay */
	pthread_create(&sig_thread_id,NULL,&sig_thread,NULL);
	
	printf("Main task going to sleep for 10 secs\n");
	/*Go to sleep for 10 seconds, if there is any interruption by signal
	then return with an error and place the remaining time in a timespec 
	structure*/
    ret = nanosleep(&sleep_until,&rem_time);
    if (ret < 0)
    {
		perror("Error sleeping:");
		printf("Remaining time is %d\n",(int)rem_time.tv_sec);
	}
    printf("Main Task returned from sleep\n");
	printf("Tasks completed\n");
   	/*Wait for the signal generating thread to join*/
    pthread_join(sig_thread_id, NULL); 
    return 0;
    }